#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Fractal Dimension MRI Pipeline (FSL-based)

T1 → fslreorient2std → BET → FLIRT (2mm) → FNIRT (config 2mm + refmask)
→ invwarp → applywarp (nn) AAL-90 MNI → native
→ ISO 1 mm → (optional LCC 26c) → SURFACE (grad/erode)
→ fractalbrain (FD) → CSV.

Run on Linux or WSL with FSL installed and accessible in the PATH.
"""

import os, sys, argparse, subprocess, shutil, glob
import numpy as np
import nibabel as nib
from nilearn import datasets, image as nlimage
from scipy.ndimage import (
    binary_erosion, binary_dilation, binary_opening, binary_closing,
    label, generate_binary_structure
)

# -----------------------
# Utility functions
# -----------------------
def run(cmd, env=None, cwd=None):
    """Run a shell command with logging."""
    print("[RUN]", " ".join(cmd))
    subprocess.check_call(cmd, env=env, cwd=cwd)

def check_fsl():
    """Verify that required FSL binaries are available in the PATH."""
    for exe in ["fslreorient2std", "bet", "flirt", "fnirt", "invwarp", "applywarp"]:
        if shutil.which(exe) is None:
            raise RuntimeError(f"[ERROR] Missing FSL binary: {exe}. Check your PATH/FSL installation.")
    if os.environ.get("FSLDIR") is None:
        print("[WARN] FSLDIR is not set. This is fine if FSL binaries are in the PATH.")

def save_nifti_like(img_nii, out_path):
    """Save a NIfTI image to disk."""
    nib.save(img_nii, out_path)

# -----------------------
# AAL Atlas helpers
# -----------------------
def aal90_ids_from_nilearn_values_correct():
    """
    Get IDs for AAL-90 regions:
    - Use nilearn’s official LUT (index-value <-> label)
    - Remove Cerebellum* and Vermis*
    - Keep subcortical regions
    """
    atlas = datasets.fetch_atlas_aal(version="SPM12")
    indices = list(map(int, atlas["indices"]))
    labels  = atlas["labels"]
    lut = dict(zip(indices, labels))
    keep = set()
    for val, name in lut.items():
        low = name.lower()
        if ("cerebel" in low) or ("vermis" in low):
            continue
        keep.add(int(val))
    return keep

def explode_atlas_to_rois(atlas_path, out_dir, keep_ids=None):
    """Split a label atlas into binary ROI masks."""
    os.makedirs(out_dir, exist_ok=True)
    atlas = nib.load(atlas_path)
    datai = np.rint(atlas.get_fdata()).astype(np.int32)
    aff   = atlas.affine
    hdr   = atlas.header
    all_labels = np.unique(datai)
    all_labels = all_labels[all_labels != 0]
    labels = [int(l) for l in all_labels if (keep_ids is None or int(l) in keep_ids)]

    print(f"[DBG] explode: raw_nonzero={len(all_labels)}, selected={len(labels)}")
    if labels:
        print("[DBG] sample kept IDs (first 10):", sorted(labels)[:10])

    saved = 0
    for rid in sorted(labels):
        mask = (datai == rid).astype(np.uint8)
        if mask.sum() == 0:
            continue
        out_path = os.path.join(out_dir, f"roi-{rid:04d}.nii.gz")
        nib.save(nib.Nifti1Image(mask, aff, hdr), out_path)
        saved += 1
    return saved

# -----------------------
# Resampling + cleanup + surface
# -----------------------
def keep_largest_cc_26(vol_bool: np.ndarray) -> np.ndarray:
    """Keep the largest 26-connected component."""
    struct = generate_binary_structure(3, 3)  # 26-connectivity
    lab, n = label(vol_bool, structure=struct)
    if n <= 1:
        return vol_bool
    counts = np.bincount(lab.ravel())
    counts[0] = 0
    k = counts.argmax()
    return (lab == k)

def remove_small_components_26(vol_bool: np.ndarray, zooms, min_vox=0, min_mm3=0.0) -> np.ndarray:
    """
    Remove 26-connected components smaller than min_vox or min_mm3.
    If both thresholds are > 0, both conditions must be met.
    """
    if not np.any(vol_bool):
        return vol_bool

    struct = generate_binary_structure(3, 3)
    lab, n = label(vol_bool, structure=struct)
    if n == 0:
        return vol_bool

    vx_vol = float(zooms[0] * zooms[1] * zooms[2]) if len(zooms) >= 3 else 1.0
    keep = np.zeros(n+1, dtype=bool)
    keep[0] = False

    counts = np.bincount(lab.ravel())
    for i in range(1, n+1):
        vox = counts[i]
        mm3 = vox * vx_vol
        cond_vox = (min_vox <= 0) or (vox >= min_vox)
        cond_mm3 = (min_mm3 <= 0) or (mm3 >= min_mm3)
        if cond_vox and cond_mm3:
            keep[i] = True

    return keep[lab]

def resample_to_iso_like(nii_in_path, nii_out_path, iso=1.0, use_lcc=False,
                         morph_mode="none", morph_iters=0,
                         cleanup_min_vox=0, cleanup_min_mm3=0.0):
    """
    Resample to isotropic voxel size (nearest neighbor).
    Optional steps:
    - Keep only the largest component (26c)
    - Morphological smoothing (open/close)
    - Small component cleanup
    """
    img = nib.load(nii_in_path)
    A = img.affine.copy()
    # Orthonormalize and impose voxel size
    U, _, Vt = np.linalg.svd(A[:3, :3])
    R = U @ Vt
    A[:3, :3] = R * float(iso)
    out = nlimage.resample_img(img, target_affine=A, interpolation="nearest")
    data = (out.get_fdata() > 0.5)

    if use_lcc:
        data = keep_largest_cc_26(data)

    if morph_mode in ("open", "close") and morph_iters > 0:
        struct = np.ones((3,3,3), dtype=bool)
        if morph_mode == "open":
            data = binary_opening(data, structure=struct, iterations=int(morph_iters))
        else:
            data = binary_closing(data, structure=struct, iterations=int(morph_iters))

    if (cleanup_min_vox > 0) or (cleanup_min_mm3 > 0):
        data = remove_small_components_26(
            data.astype(bool),
            zooms=out.header.get_zooms(),
            min_vox=int(cleanup_min_vox),
            min_mm3=float(cleanup_min_mm3)
        )

    data = data.astype(np.uint8)
    out_img = nib.Nifti1Image(data, out.affine, out.header)
    out_img.header.set_zooms((iso, iso, iso) + out_img.header.get_zooms()[3:])
    nib.save(out_img, nii_out_path)

def make_surface_mask(nii_in_path, nii_out_path, mode="grad", iters=1):
    """
    Create a 'surface' mask from a binary volume.
    - mode='grad': surface = dilate(vol) XOR erode(vol) (~2 vox shell)
    - mode='erode': surface = vol & ~erode(vol, iters)
    """
    nii = nib.load(nii_in_path)
    vol = (nii.get_fdata() > 0)

    if not np.any(vol):
        nib.save(nib.Nifti1Image(vol.astype(np.uint8), nii.affine, nii.header), nii_out_path)
        return

    struct = np.ones((3,3,3), dtype=bool)

    if mode == "grad":
        er = binary_erosion(vol, structure=struct, iterations=1, border_value=0)
        di = binary_dilation(vol, structure=struct, iterations=1, border_value=0)
        surf = np.logical_xor(di, er)
    else:  # 'erode'
        iters = max(1, int(iters))
        er = binary_erosion(vol, structure=struct, iterations=iters, border_value=0)
        surf = vol & (~er)

    if not np.any(surf):
        surf = vol  # fallback if ROI is too small

    nib.save(nib.Nifti1Image(surf.astype(np.uint8), nii.affine, nii.header), nii_out_path)

# -----------------------
# Main
# -----------------------
def parse_args():
    ap = argparse.ArgumentParser(
        description="FSL + AAL (MNI→native NN) → AAL-90 cortex ROIs → ISO 1 mm → (optional LCC) → SURFACE → fractalbrain (FD)."
    )
    ap.add_argument("--t1", required=True, help="Path to T1 NIfTI (.nii or .nii.gz)")
    ap.add_argument("--out-root", required=True, help="Output directory (will be created)")
    ap.add_argument("--subject", default="sub-Example", help="Subject prefix for outputs")
    ap.add_argument("--voxel", type=float, default=1.0, help="Isotropic voxel size in mm (default: 1.0)")
    ap.add_argument("--run-fract", action="store_true", help="Run fractalbrain.fract + fract2table at the end")
    ap.add_argument("--lcc", action="store_true", help="Keep only the largest 26c component after resampling")
    ap.add_argument("--surface-mode", choices=["grad","erode"], default="grad",
                    help="Surface mode: 'grad' (~2 vox) or 'erode' (iters vox)")
    ap.add_argument("--surface-iters", type=int, default=1,
                    help="Thickness for 'erode' mode")
    ap.add_argument("--cleanup-min-vox", type=int, default=0,
                    help="Min size of connected components (voxels)")
    ap.add_argument("--cleanup-min-mm3", type=float, default=0.0,
                    help="Min size of connected components (mm^3)")
    ap.add_argument("--morph-smooth", choices=["none","open","close"], default="none",
                    help="Morphological smoothing mode")
    ap.add_argument("--morph-iters", type=int, default=0,
                    help="Number of iterations for morphological smoothing")
    return ap.parse_args()

# -----------------------
# Entry point
# -----------------------
if __name__ == "__main__":
    sys.exit(main())
